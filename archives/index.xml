<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Archives on Nikaeraintokyo.</title>
    <link>https://nikaera.com/archives/</link>
    <description>Recent content in Archives on Nikaeraintokyo.</description>
    <image>
      <url>https://nikaera.com/cover_image.jpg</url>
      <link>https://nikaera.com/cover_image.jpg</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <lastBuildDate>Thu, 24 Jun 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://nikaera.com/archives/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>📝 pytest で alembic のマイグレーションを行う方法</title>
      <link>https://nikaera.com/archives/pytest-sqlalchemy-alembic/</link>
      <pubDate>Thu, 24 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://nikaera.com/archives/pytest-sqlalchemy-alembic/</guid>
      <description>はじめに FastAPI と SQLAlchemy を利用して Web API 開発を行っていた際、SQLAlchemy のマイグレーションツールである alembic を利用していました。
ただ E2E テストを書こうとした際に、pytest 実行中に alembic でデータベースマイグレーションを行う方法が分からず模索していました。結果的にマイグレーションのやり方は分かったものの一応今後も利用するかもしれないため、その内容を記事として残しておくことにしました。
本記事内で利用しているソースコードを含む FastAPI プロジェクトを GitHub リポジトリ上にアップしておいたので、詳細を確認されたい方がいれば、是非そちらもご活用くださいませ。
alembic でマイグレーションを行う conftest.py にグローバルで利用するマイグレーション用の fixture を定義すれば OK です。
# conftest.py import os import alembic.config import pytest from sqlalchemy import create_engine from sqlalchemy.ext.declarative import declarative_base from sqlalchemy.orm import sessionmaker from sqlalchemy_utils import database_exists, create_database, drop_database # テスト用の初期データを定義した module を import する (必要があれば) # from .seed import users, contents # 指定したパラメータを用いて alembic によるデータベースマイグレーションを行う # 引数のデフォルト設定では全てのマイグレーションを実行するようになっている def migrate(migrations_path, alembic_ini_path=&amp;#39;alembic.</description>
    </item>
    
    <item>
      <title>📝 Chrome 拡張で 1つのウインドウを使い回す方法</title>
      <link>https://nikaera.com/archives/chrome-extension-only-one-window/</link>
      <pubDate>Sun, 20 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://nikaera.com/archives/chrome-extension-only-one-window/</guid>
      <description>Teemo という Chrome 拡張を開発したのですが、その際 1 つのウインドウを使い回す構成にしたいなと考えていました。
例えば何も考えずに chrome.windows.create を Chrome 拡張を開くたびに呼び出すと、呼び出すたびにウインドウが新規作成されてしまいます。そうすると、都度画面に不要なウインドウが出てきて邪魔になるだけでなく、手動で不要なウインドウを消す作業をユーザーに強いることとなってしまいます。。🙃
上記のような挙動が望まれるケースもあると思いますが、Teemo ではウインドウ間を頻繁に行き来するため、ショートカットを利用して拡張機能を呼び出すことを見込んでいました。そのため、ショートカットを利用して拡張機能を呼び出すたびにウインドウが新規作成され続ける挙動は望んでいませんでした。
1 つのウインドウを使い回すためには、chrome.windows.create 時に作成される window の id を保持しておきます。その後、Chrome 拡張が呼び出されるたびに window が既に存在するかどうかを保持していた id を元にチェックします。既に window が存在していた場合はそれを使いまわします。存在していなかった場合は、chrome.windows.create で window を新規作成します。
// window の id を保持しておくための変数 let vid = -1; chrome.browserAction.onClicked.addListener(function () { // vid の値を元に Chrome 拡張で開いた window の取得を試みる  chrome.windows.get(vid, function (chromeWindow) { // エラーが無く、既に window が存在している場合は、  // そのステータスを { focused: true } にすることで最前面に呼び出す  if (!chrome.runtime.lastError &amp;amp;&amp;amp; chromeWindow) { chrome.</description>
    </item>
    
    <item>
      <title>📝 Node.js パッケージを公開するための GitHub Actions を構築する</title>
      <link>https://nikaera.com/archives/yarn-publish-github-actions/</link>
      <pubDate>Sun, 20 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://nikaera.com/archives/yarn-publish-github-actions/</guid>
      <description>react-emoji-textarea の開発を行った際、リリースを作成したら自動的に Node.js パッケージにライブラリが公開される仕組みがほしいと考え、GitHub Actions でそれを実現することにしました。
その際、公式サイトに 公開されている内容 を参考に GitHub Actions を作成したのですが、そのまま利用すると私の環境では下記のエラーが発生してしまいました。
error Couldn&amp;#39;t publish package: &amp;#34;https://registry.yarnpkg.com/@nikaera/react-emoji-textarea: You do not have permission to publish \&amp;#34;react-emoji-textarea\&amp;#34;. Are you logged in as the correct user?&amp;#34; 上記のエラーについて調査しながら改修したところ、最終的に下記の GitHub Actions で Node.js パッケージを公開できるようになりました。secrets.NPM_TOKEN には NPM Token を登録します。
name: Node.js Package on: # workflow_dispatch を追加して手動でも実行できるよう改修 workflow_dispatch: release: types: [created] jobs: build: runs-on: ubuntu-latest steps: - uses: actions/checkout@v2 - uses: actions/setup-node@v2 with: node-version: &amp;#34;14.x&amp;#34; registry-url: &amp;#34;https://registry.npmjs.org&amp;#34; # registry.</description>
    </item>
    
    <item>
      <title>📔 チャットの短文作成に便利な Chrome 拡張機能を開発してみた</title>
      <link>https://nikaera.com/archives/teemo-first-release/</link>
      <pubDate>Sat, 12 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://nikaera.com/archives/teemo-first-release/</guid>
      <description>はじめに 📝 最近とある事情により Twitter の DM を利用しているのですが、Slack などのように絵文字をショートカット入力できないことにフラストレーションが溜まってきていました。そのため、絵文字をショトカで入力可能にしてくれる Chrome 拡張機能を探したのですが見つけられませんでした。
そこで、無いなら作ろうということで Teemo を開発しました。
ソースコードは GitHub 上で公開しています。 何かご要望等ございましたら PR や Issue 作成頂けますと喜びます。Teemo の実際の挙動については下記の動画で確認できます 🎥   考えていたこと 💭 今回 Teemo の開発を行うに当たり、考えていた点は下記になります。
 よくある : 入力からの絵文字ショートカットを導入する  Slack や GitHub、JIRA などではおなじみの入力方法 ⌨️   パレットから選択する際は半角英数字で検索できるようにしたい  Twitter では日本語で検索しないと絵文字が探せない 🔍 普段英数字で絵文字検索をするので目的の絵文字が見つけづらい 🕵️   拡張機能を利用することで文章入力の煩わしさが増加することは避けたい  コピペや文章クリアの機能等にもショトカ利用できるようにしたい 💨    プロトタイピングしながら友人に進捗をシェアしながら開発は進めていきました。本当は個人で利用する想定で進めていたのですが、割と評判が良かったため Chrome ウェブストアに公開するのを目標に動いていました。そして、Chrome ウェブストアで公開できるクオリティを目指して動いたことで満足のいく拡張機能が作れました。
使い方 ⚒️ Teemo の使い方について紹介いたします。
Teemo を Chrome 拡張機能として追加する 🛍️ まずは Chrome ウェブストア にアクセスして、Teemo を Chrome に追加する必要があります。</description>
    </item>
    
    <item>
      <title>📔 GameCI で Unity の CI 環境を GitHub Actions で構築する</title>
      <link>https://nikaera.com/archives/unity-gameci-github-actions/</link>
      <pubDate>Sat, 29 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://nikaera.com/archives/unity-gameci-github-actions/</guid>
      <description>はじめに 先日同僚が Unity の CI 環境を構築するためのライブラリである GameCI について教えてくれました。早速 GameCI の GitHub Actions を利用して、サンプルプロジェクトで色々動作検証してみたところ、Unity の CI 環境を楽に構築できることが分かりました。
もちろん、Unity Cloud Build を利用すれば CI 環境の構築は以前から楽にできました。しかし、選択肢の 1 つとして GameCI を持っておくことで、サクッと GitHub Actions に統合する形で Unity の CI 環境を導入できるのは他には無いメリットを感じました。
本記事で紹介しているソースコード、及び検証時に利用したプロジェクトは GitHub にアップ済みですので、手っ取り早く内容を把握されたい方は下記をご参照くださいませ。
https://github.com/nikaera/Unity-GameCI-Sample
業務でも利用できそうなので、GameCI を利用して CI 環境を構築する手順を記事でまとめました。
GameCI に備わっている機能紹介 GameCI には現状下記の GitHub Actions が用意されているようです。
   機能 概要     Activation Unity ライセンスを任意の Unity バージョンで発行する   Test runner Unity の PlayMode 及び EditMode のテストを実行する (テスト結果の出力にも対応)   Builder 任意の Platform ビルドを実行する (アーティファクト 利用でダウンロードも可能)   Returning a license Unity ライセンスの返却ができる (Professional License のみ対応)   Remote builder GitHub Actions のスペックでは満足のいくビルドができない際に AWS 環境でハイスペックなマシンを用意してビルドできる。ビルドのためのインフラ構築には AWS CloudFormation を使用している (現在は AWS のみ対応。今後 GCP, Azure にも対応予定とのこと)   Deployment Unity ビルドを各種 Platform 向けにデプロイする (iOS 及び Android のみ記載あり。厳密に言うと Builder でビルド出力した内容を fastlane を用いてデプロイするためのワークフロー紹介になっている)    上記を見ると既に GameCI には開発者として Unity CI に欲しい機能は最低限揃っているように見受けられました。 また本記事では、今後機会があれば試してみたいと考えていますが Remote builder 及び Deployment については言及していません。</description>
    </item>
    
    <item>
      <title>📝 Rails で config/database.yml よりも ENV[&#39;DATABASE_URL&#39;] の設定が優先される話</title>
      <link>https://nikaera.com/archives/rails-database-url/</link>
      <pubDate>Sat, 29 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://nikaera.com/archives/rails-database-url/</guid>
      <description>MySQL を利用する Rails プロジェクトを起動しようとしたところ、下記のエラーが発生しました。
bin/rails s # データベースアダプターには mysql2 を選択している状態なのに postgresql で接続しようとしている Error loading the &amp;#39;postgresql&amp;#39; Active Record adapter. Missing a gem it depends on? pg is not part of the bundle. Add it to your Gemfile. (LoadError) # config/database.yml ファイルの中身一部抜粋 # mysql2 をデータベースアダプターとして利用しているため、 # PostgreSQL 接続のための pg ライブラリの追加を求めるエラーが発生しているのは何かおかしい。。 default: &amp;amp;default adapter: mysql2 #... 何でや、、と思い Rails のドキュメントを読んでいた所、公式サイトに Connection Preference に関する記述を見つけました。
 Since pool is not in the ENV[&amp;lsquo;DATABASE_URL&amp;rsquo;] provided connection information its information is merged in.</description>
    </item>
    
    <item>
      <title>📝 Pillow を使って画像に縦書きテキストを埋め込む</title>
      <link>https://nikaera.com/archives/pillow-vertical-writing/</link>
      <pubDate>Sat, 22 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://nikaera.com/archives/pillow-vertical-writing/</guid>
      <description>はじめに 縦書きテキストを画像に埋め込みたいと頼まれたので、
Python 製の画像処理ライブラリ Pillow を使ってサクッと実装してみました。
一応ソースコードは Gist にもアップ済みです ✍️
https://gist.github.com/nikaera/c1049708ff548b06cab0ae377adc4ac7
動作環境  Python 3.9.5 Pillow 8.2.0  画像に縦書きテキストを埋め込む まずは今回利用する Pillow を予めインストールしておきます。
pip install Pillow その後 main.py を作成して下記を入力します。
テキストを埋め込みたい画像を main.py と同じフォルダに sample.jpeg という名前で配置しておきます。
# Pillow の利用するモジュールのみをインポートする from PIL import Image, ImageDraw, ImageFont # 読み込みたいフォント情報を入力する font_name = &amp;#34;/System/Library/Fonts/ヒラギノ角ゴシック W0.ttc&amp;#34; font_size = 48 font = ImageFont.truetype(font_name, font_size) # テキストを埋め込みたい画像 sample.jpeg を読み込む im = Image.open(&amp;#39;sample.jpeg&amp;#39;) d = ImageDraw.Draw(im) # 画像に埋め込みたいテキスト情報を入力する # (後述するが、改行コードには未対応) text = &amp;#34;bifdLcFCKXtFJZmPZhzdefjhhYTtuJPAYsR&amp;#34; # 文章を改行するまでの文字数を入力する split_number = 11 # split_number で指定した文字数ごとに分割され配列に格納される # ref: https://qiita.</description>
    </item>
    
    <item>
      <title>📔 PlayFab の API 制限に引っかかった</title>
      <link>https://nikaera.com/archives/playfab-api-call-limitation/</link>
      <pubDate>Sun, 14 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://nikaera.com/archives/playfab-api-call-limitation/</guid>
      <description>はじめに PlayFab で CloudFunction を利用しているときに API 制限に引っかかってしまいました。負荷テストをした際に初めて気づいたのですが、公式ページにも言及が無かったため発覚が遅れてしまいました。そのため、PlayFab に依存していた機能を部分的に外す必要が出てきてしまい苦労しました。
本記事では、上記のような事態に陥る方を減らすため、API 制限に気づくまでの軌跡を辿りながら、PlayFab の CloudFunction を利用する際の注意点について、記事として残しておきたいと思います。
PlayFab の API 制限に引っかかった要因 PlayFab の CloudFunction を利用すると、PlayFab 経由で独自 Web API を実行することが可能になります。また、CloudFunction 経由で独自 Web API を実行すると、PlayFab ユーザ情報が含まれたパラメタが含まれた状態でリクエストが飛んでくるため、その情報を利用することでサーバーサイドで PlayFab の操作を行うことが出来るようになり大変便利です。
そのため、あるプロジェクトでは PlayFab CloudFunction を Azure Function や AWS Lambda のような FaaS を使っている感じで利用しておりました。そして、その利用の仕方は誤りであったことに後々気づきます&amp;hellip;
負荷テストを実装するフェーズで CloudFunction を大量に叩いてみる PlayFab の CloudFunction を実行するにあたり利用した PlayFab の API は Server-Side Cloud Script - Execute Function というものになります。
同接 2000 人想定で負荷テストのシナリオを実装することが求められていたため、その通りシンプルに 2000 件同時に Server-Side Cloud Script - Execute Function を実行するシナリオを Gatling で組んでみました。すると、何回やっても数十件以上は必ずエラーが発生していることが分かりました。</description>
    </item>
    
    <item>
      <title>📝 Jest で private readonly な値をモックする方法</title>
      <link>https://nikaera.com/archives/jest-private-readonly-mock/</link>
      <pubDate>Sun, 07 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://nikaera.com/archives/jest-private-readonly-mock/</guid>
      <description>Jest でクラスの private readonly な変数を差し替えたい時に若干引っかかったのでメモっておきます。タイトルでは Jest とありますが、本記事の内容は JavaScript でモックする際の有効な手法の 1 つとして利用することが可能です。
結論から言うと変数を差し替えたい場合は下記のような記述になります。
const mockValue = &amp;#34;&amp;#34;; Object.defineProperty(service, &amp;#34;privateReadOnlyValue&amp;#34;, { value: mockValue, }); ちなみに関数を差し替えたい場合は下記のような記述になります。
Object.defineProperty(service, &amp;#34;privateSumFunction&amp;#34;, { value: jest.fn((a, b) =&amp;gt; a + b), }); 各種テストケースで使いまわしているインスタンスの private readonly な変数をモックした場合、値をリストアしたいケースも出てきました。その場合の記述としては、下記が有効でした。
// tmpService 変数に service インスタンスを clone して利用する const tmpService = Object.create(service); Object.defineProperty(tmpService, &amp;#34;privateReadOnlyValue&amp;#34;, { value: &amp;#34;&amp;#34;, }); 参考リンク  Object.create() - JavaScript | MDN Mocking read-only properties for a class · Issue #2227 · facebook/jest  </description>
    </item>
    
    <item>
      <title>📔 ブログを書く用途に特化した Gyazo のツールを開発してみた</title>
      <link>https://nikaera.com/archives/bloggimg-first-release/</link>
      <pubDate>Sun, 10 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://nikaera.com/archives/bloggimg-first-release/</guid>
      <description>はじめに いつもブログ記事に載せるキャプチャ画像の編集 &amp;amp; アップロード先として Gyazo を利用させていただいているのですが、日々使っている中で不満に感じる点もちょくちょく出てくるようになってきました。
そのため、3 連休を用いて Rust の勉強がてら Bloggimg というウェブアプリケーションを作ってみました。ソースコードは MIT ライセンスで GitHub のリポジトリにアップしております。ちなみに最初は Gyazo for Blog という名称で開発をしていたため、本記事内のスクショには Gyazo for Blog という文字列が出てきますが、現在は Bloggimg という名称になっております。。
Bloggimg を開発したのは、ブログ記事を書く際に利用する画像のアップロードから加工、マークダウンとして利用するまでのフローを最適化したかったからです。 ブログ記事を書く際に、記事内で用いるスクショ画像の加工や、そのアップロードにすごく時間を取られてしまうなーと日頃から感じていたのでそれを解決したかったのです。✅
開発中に得た知見等については別途技術記事として書いて残す予定です。
考えていたこと 今回 Bloggimg の開発を行うに当たり、考えていた点は下記になります。
 画像の編集ツールは引き続き Gyazo に用意されているものを使う  既に最高に使いやすい 👑   キャプチャ画像をアップロードする際に、自動的に特定のコレクションに紐付けるようにする  技術記事毎にコレクションを分けて管理しているため、技術記事を書いている最中にアップするキャプチャ画像は全て特定のコレクションにまとまっていて欲しい   ワークスペースのようなツールを目指し、ブログを書く時だけに使える機能を開発する  例えば、ワンクリックで画像マークダウンの記述がコピーできたり、画像のアップロードをし直しやすくするため画像削除がお手軽に出来るよう削除ボタンに即アクセス出来るようにしたり&amp;hellip;    特にアップした画像を 自動的に特定のコレクションに紐付けるようにする については本記事で紹介しているウェブアプリケーションを作成するキッカケとなった点なので外せない点でした。
使い方 Bloggimg の使い方についてご紹介いたします。
ログインする Bloggimg を利用するためには、まず Gyazo アカウントでログインして頂く必要がございます。トップページの右上にあるログインボタンから Gyazo アカウントでログインします。
1. トップページ右上に配置されたログインボタンから Gyazo アカウント認証を行う</description>
    </item>
    
    <item>
      <title>📝 AWS Lambda で cron みたいに定期実行する</title>
      <link>https://nikaera.com/archives/aws-lambda-cron/</link>
      <pubDate>Mon, 04 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://nikaera.com/archives/aws-lambda-cron/</guid>
      <description>コンテナをホットスタンバイさせるために EC2 でインスタンス起動して cron で ping 飛ばしていたのですが、コスト的に勿体ないなーと思っていました。しかし、「AWS Lambda 使えばいいじゃん」という指摘を受け、確かにってなったので cron で定期実行していた ping 処理を AWS Lambda + EventBridge で置き換えました。
実は Heroku Scheduler とか使って同様のことをしていた時期もあったのですが、10分毎しか実行できない制約があったりして使い勝手が悪かったので、後々も使っていけそうな知見な気がしたのでメモがてら記事で残しておくことにしました。
まず、AWS Console から Lambda サービスを選択して関数を新たに作成します。
1. AWS Lambda のトップ画面から関数作成のための画面に遷移する
2. 必要な情報を入力して Lambda の関数を作成する
関数が作成でき次第、ping 処理を書いていきます。http リクエストを行うためのライブラリとして Node.js の標準モジュール(https) を利用します。
Lambda 関数作成直後の index.js は下記のような記述になっていると思います。
// index.js exports.handler = async (event) =&amp;gt; { // TODO implement  const response = { statusCode: 200, body: JSON.stringify(&amp;#39;Hello from Lambda!&amp;#39;), }; return response; }; こちらを Node.</description>
    </item>
    
    <item>
      <title>📔 2020年の振り返り</title>
      <link>https://nikaera.com/archives/summarize-2020/</link>
      <pubDate>Thu, 31 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://nikaera.com/archives/summarize-2020/</guid>
      <description>はじめに 本記事のカバー画像は Michal Jarmoluk による Pixabay からの画像です。
今年は結果的にプライベートと仕事の両面で充実した年にできました。来年の自分が今を振り返れるように、今年始めからの記憶を引っ張り出しながら総括しました。
今年問わず作ったものは Tech ページに、技術記事については RSS Feeds にまとめてあります。
出来事 1月  Death Stranding のプラチナ獲得 弊社に面接にいらっしゃったベテラン開発者の方に何でうちに応募してくださったのか聞いたら、僕の Twitter や Qiita アカウントを見てくださり技術力がありそうと判断してくれたからと聞いて爆嬉しかった ambr オフ会参加 (オフィシャルなオフ会に初参加) Quest 用アプリケーションの初リリース体験実績解除  申請時の知見の一部については Qiita 記事 として投下   Android で AR アプリケーションの開発及び、マルチプレイを可能にするバックエンド開発を担当した  2月  Docker で各種モバイル VR 向けの Unity ビルドが出来るようにした フルリモートでアジャイルな開発チームにジョインする (WebView/ReactNative/iOS/Android)  主は ReactNative の iOS/Android のネイティブプラグイン開発 コア機能の実装にのみ注力しパフォーマンスチューニング等々を行っていたためポジション的にはひたすら地味だった    3月  note デビューした  初投稿は 精神衛生を保つため Chrome で Twitter を閲覧している時にフォロワー数を非表示にする っていうやつ   お題が「Home」の web1week に参加した  参加した時に投稿した記事はこちら    4月  会社の Medium ブログ開設 したのと、いくつか記事を寄稿した  Azure Kinect DK の開発環境構築から KinectFusion のサンプルを動かすまで 最短で Magic Leap 1 の開発環境を構築する   色々工夫して iPhone TrueDepth を WebRTC でブラウザに転送して、Three.</description>
    </item>
    
    <item>
      <title>📝 React で highlight.js を適用する方法</title>
      <link>https://nikaera.com/archives/react-highlightjs/</link>
      <pubDate>Wed, 23 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://nikaera.com/archives/react-highlightjs/</guid>
      <description>Zenn.badge を作成する時に React に highlight.js を組み込もうとしたのですが、若干躓いてしまったので対処法についてメモっておきます。
React は既にプロジェクトにインストール済みと仮定します。
# 一応 React をインストールするためのコマンドは ↓ npm i --save react react-dom まずは highlight.js を NPM or Yarn でインストールします。
# NPM で highlight.js をインストールする npm i --save highlight.js yarn add highlight.js その後、React ソースコードに highlight.js を組み込みます。 ソースコードの全体像は下記のとおりです。
import Head from &amp;#39;next/head&amp;#39; import styles from &amp;#39;../styles/Home.module.css&amp;#39; import React, { useState, useEffect } from &amp;#39;react&amp;#39;; /** highlight.js を import する */ import hljs from &amp;#39;highlight.js/lib/core&amp;#39;; /** シンタックスハイライトしたい言語のみ import として登録する 今回は html をハイライトしたかったので xml を import した デザインは highlight.</description>
    </item>
    
    <item>
      <title>📝 Hugo で外部リンクを target=&#34;_blank&#34; で開く方法</title>
      <link>https://nikaera.com/archives/hugo-open-external-link-in-a-new-window/</link>
      <pubDate>Thu, 17 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://nikaera.com/archives/hugo-open-external-link-in-a-new-window/</guid>
      <description>Hugo で設定した外部リンクを開くときは別ウィンドウで開けるようにしたかったので、Hugo のテーマファイルをオーバーライドして対応しました。外部リンクが設定されているときのみ a タグに target=&amp;quot;_blank&amp;quot; rel=&amp;quot;noopener noreferrer&amp;quot; が追加されるようにしました。
テンプレートファイルは GO の HTML テンプレートで書かれているので、その書式にしたがって a タグの属性を書き換えることで、外部リンクの場合は target=&amp;quot;_blank&amp;quot; rel=&amp;quot;noopener noreferrer&amp;quot; を追加します。
下記は hugo-PaperMod で、メインメニューの a タグに target=&amp;quot;_blank&amp;quot; rel=&amp;quot;noopener noreferrer&amp;quot; を追加するときのサンプルになります。
&amp;lt;ul class=&amp;#34;menu&amp;#34; id=&amp;#34;menu&amp;#34; onscroll=&amp;#34;menu_on_scroll()&amp;#34;&amp;gt; &amp;lt;!-- `.Site.Menues.main` の要素数 (メニュー数) ループします --&amp;gt; {{- range .Site.Menus.main }} &amp;lt;!-- 要素内の .URL にアクセスすることで設定されているリンクにアクセスする。 設定されている URL のプレフィクスが https:// or http:// であれば、 絶対リンクが設定されているはずなため、外部リンクが設定されているとみなす。 --&amp;gt; {{- $is_abs_url := or (strings.HasPrefix .URL &amp;#34;https://&amp;#34;) (strings.HasPrefix .URL &amp;#34;http://&amp;#34;) }} &amp;lt;!-- もし外部リンクが設定されていれば、そのまま .URL の内容を出力する。 そうでなければ、内部リンクを language プレフィクスを付与した形で出力する。 --&amp;gt; {{- $menu_item_url := (cond $is_abs_url .</description>
    </item>
    
    <item>
      <title>📔 Moonlander というエルゴノミクスキーボードのススメ</title>
      <link>https://nikaera.com/archives/introduction-to-moonlander/</link>
      <pubDate>Sun, 13 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://nikaera.com/archives/introduction-to-moonlander/</guid>
      <description>はじめに 最近 ErgoDox EZ からの乗り換えで Moonlander というエルゴノミクスキーボードを使っているのですが、諸々非常に満足しています。コンパクトながら安定感のある打ち心地でカスタマイズ性も高く、試行錯誤しながら自分好みにセットアップして使い勝手を最適化することができます。
バックライトがあり、デフォで 様々な光り方 が用意されているのも非常にカッコよいです。あまりキーボードのバックライトを気にしたことは今まで無かったのですが、何となく 1日毎にエフェクトを切り替えると良い気分転換になります。なんとなくだけど。。ｗ
また、これについてはエルゴノミクスキーボード全般に言える話で Moonlander に限った話では無い気がしますが、体がこわばった姿勢にならなくなり、肩が開いてリラックスした姿勢でタイピングできます。
そのため、長時間 PC で作業していても、呼吸が浅くなりづらく、肩への負担も少なく感じます。現に筆者はキーボードを変えただけで生活習慣変えた覚えがないにも関わらず、長時間作業しても疲れにくくなりましたし、肩こりになりにくくなりました。
毎年冬になると肩こりになる体質だったのですが、ErgoDox EZ を採用し始めてから肩こりに悩まされることは無くなりました。
今回はそんな気に入って仕事プライベート問わず酷使している Moonlander についての紹介記事を書いていこうと思います。
ちなみに筆者はキーコンフィグを軽くカスタマイズしている程度のライトユーザーです。
セットアップが簡単 Web から簡単にキーコンフィグを設定することが可能です。キーコンフィグ設定のためのサービスは Ergodox EZ Configurator というやつです。名前に Ergodox がついていますが ZSA Technology Labs から購入可能なキーボード全てに対応しています。(Moonlander にも Planck にも対応)
今回は Moonlander Mark I を利用する
Search layouts ボタンをクリックすることで、他の人が既にカスタマイズしたキーコンフィグをダウンロードしたり、そのキーコンフィグを元に自分用のキーコンフィグをカスタマイズすることも可能です。
ちなみにデフォルトのキーコンフィグは Configure ボタンをクリックすると確認することができます。もちろん、そこからキーコンフィグをカスタマイズしていくことも可能です。
また、カスタマイズした設定内容は常に Ergodoz EZ Configurator に保存されるので、後から細かくキーコンフィグを修正していくといったことも可能です。 最初のうちは頻繁にキーコンフィグに微修正入れると思うので、めっちゃ便利でした。
Ergodoz EZ Configurator の Search layouts で &amp;ldquo;coding&amp;rdquo; で検索した結果
ちなみに僕が使用しているキーコンフィグは こちら です。他の方々のキーコンフィグと比べると大分シンプルですが、その分初見の方でも扱いやすいコンフィグだと思います多分&amp;hellip;
キーコンフィグの更新も簡単 キーコンフィグの設定が完了したら Wally というツールを使ってキーコンフィグ設定を実際にキーボードに反映させることが可能です。</description>
    </item>
    
    <item>
      <title>📔 誕生日のノリでアドベントカレンダーに投稿予約して感じた変化</title>
      <link>https://nikaera.com/archives/birthday-2020/</link>
      <pubDate>Sun, 06 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://nikaera.com/archives/birthday-2020/</guid>
      <description>はじめに まず、私の誕生日は 11/6 なので本日 12/6 は誕生日からちょうど 1ヶ月後になります。
誕生日なので何か書くことにした✍️ | なんでもに参加しました！ https://t.co/1NXySfMlak #Crieit #crieit_advent_calendar @crieitcommunityより
&amp;mdash; 𝚗𝚒𝚔𝚊𝚎𝚛𝚊 (@n1kaera) November 2, 2020  はい。完全にノリで参加しようと投稿予約してから、後日確認して気づきました。。ｗ しかし、その間違えに気づいてから、何を投稿しようかなあと考え始めた時に、ふと「以前の自分だったら絶対ノリでアドベントカレンダーに登録するっていう行動しないよなあ」ということに気づきました。
そこで、今回は以前の自分と比較して、今の自分がどう変わったのか考察してみることにしました。この記事書いてるときは誕生日からまだ 1週間経ってないし、ちょうど考察するには良い機会かなと思って。
以前の自分 Photo by Luis Villasmil on Unsplash
以前はやりたいことがあっても全部後回しにしてしまっていました。何故かと言うと仕事やプライベートも含めて、他に直近でやらなければならない、もしくはそう思いこんでいる TODO があったときに、それらが残っていると次々に心配事や考え事が増えていってしまい、やりたいことに集中出来なくなるからです。
つまり、やりたいことは本気で集中できるタイミングが来たらやろうと考えていました。
そのため、読もうと思って買った本を読みたい、買って届いた新作ゲームをやりたい、OSS 活動をしてみたい、ライブラリを自分で作成してみたい等々のやりたいことは全て後回しになっていました。
何も考えないでサクッと取り組めるプレイ済みのゲームを遊んだり、気に入っている Youtube の動画を何度も繰り返し見たりして時間を浪費していました。
ボーッとしながら何も考えないで過ごす時間や遊ぶ時間は気力を養う上で重要で必要だと認識しているのですが、それだけを余暇に費やすのは少し勿体ないなと感じていました。
そして、ある時ふと気づきました。多分このままの生活してると連休とか仕事の区切りのタイミングとかでしか、自分がやりたいことに取り組むことはできないなと。。ちなみに、私はいわゆる ON/OFF みたいな切り替えが出来ないタイプなので、「仕事が終わったらスイッチを OFF にしてプライベートを全力で楽しむようにする」とかは無理なタイプです。
そこで、過去自分が気分がノリ続けて作業できたり、新しいことに挑戦し始めたときのことを思い返しながら、現状改善のために簡単に出来ることからやってみようと 1年前くらい前から行動を起こし始めました。
試したこと Free-PhotosによるPixabayからの画像
まず、前提として下記項目はあえて頑張って解決するとかは諦めました。理由は中学生くらいの時から「そうだったなあ」って感じていることだったので潔く諦めた感じです。
 仕事プライベート関係なく、やりたくない面倒な TODO を意識してしまい無駄に疲れる  ふとした瞬間に思い出して不快になるかつ、それらの TODO は後回しにしてしまいがちなので、更に不快になる機会が増えてきて、結果疲れ続ける   やるべき必要がある TODO が増えてくると最優先で迅速に全部片付けたくなる  それらが意識の端にあると心を休めた状態で日々を過ごすことが難しくなってきて、結果疲れ続ける    上記の解決を諦めても、やりたいことが自然と出来る環境が作れるようにしようとしました。</description>
    </item>
    
  </channel>
</rss>
